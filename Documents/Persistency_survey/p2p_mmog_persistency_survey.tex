\documentclass[10pt,a4paper,journal,cspaper,compsoc]{IEEEtran}

% Some very useful LaTeX packages include:
% (uncomment the ones you want to load)

% *** CITATION PACKAGES ***
%
\ifCLASSOPTIONcompsoc
  % IEEE Computer Society needs nocompress option
  % requires cite.sty v4.0 or later (November 2003)
  \usepackage[nocompress]{cite}
\else
  % normal IEEE
  \usepackage{cite}
\fi
% cite.sty was written by Donald Arseneau
% V1.6 and later of IEEEtran pre-defines the format of the cite.sty package
% \cite{} output to follow that of IEEE. Loading the cite package will
% result in citation numbers being automatically sorted and properly
% "compressed/ranged". e.g., [1], [9], [2], [7], [5], [6] without using
% cite.sty will become [1], [2], [5]--[7], [9] using cite.sty. cite.sty's
% \cite will automatically add leading space, if needed. Use cite.sty's
% noadjust option (cite.sty V3.8 and later) if you want to turn this off.
% cite.sty is already installed on most LaTeX systems. Be sure and use
% version 4.0 (2003-05-27) and later if using hyperref.sty. cite.sty does
% not currently provide for hyperlinked citations.
% The latest version can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/cite/
% The documentation is contained in the cite.sty file itself.
%
% Note that some packages require special options to format as the Computer
% Society requires. In particular, Computer Society  papers do not use
% compressed citation ranges as is done in typical IEEE papers
% (e.g., [1]-[4]). Instead, they list every citation separately in order
% (e.g., [1], [2], [3], [4]). To get the latter we need to load the cite
% package with the nocompress option which is supported by cite.sty v4.0
% and later. Note also the use of a CLASSOPTION conditional provided by
% IEEEtran.cls V1.7 and later.


% *** GRAPHICS RELATED PACKAGES ***
%
  \usepackage[pdftex]{graphicx}
  \graphicspath{{../Figures/}}
  \DeclareGraphicsExtensions{.pdf,.png}
  \usepackage{color}

% *** MATH PACKAGES ***
%
\usepackage[cmex10]{amsmath}
% A popular package from the American Mathematical Society that provides
% many useful and powerful commands for dealing with mathematics. If using
% it, be sure to load this package with the cmex10 option to ensure that
% only type 1 fonts will utilized at all point sizes. Without this option,
% it is possible that some math symbols, particularly those within
% footnotes, will be rendered in bitmap form which will result in a
% document that can not be IEEE Xplore compliant!
%
% Also, note that the amsmath package sets \interdisplaylinepenalty to 10000
% thus preventing page breaks from occurring within multiline equations. Use:
%\interdisplaylinepenalty=2500
% after loading amsmath to restore such page breaks as IEEEtran.cls normally
% does. amsmath.sty is already installed on most LaTeX systems. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/amslatex/math/

%\usepackage{amssymb}%............................ AMS Symbol fonts



% *** SPECIALIZED LIST PACKAGES ***
%
%\usepackage{algorithmic}
% algorithmic.sty was written by Peter Williams and Rogerio Brito.
% This package provides an algorithmic environment for describing algorithms.
% You can use the algorithmic environment in-text or within a figure
% environment to provide for a floating algorithm. Do NOT use the algorithm
% floating environment provided by algorithm.sty (by the same authors) or
% algorithm2e.sty (by Christophe Fiorio) as IEEE does not use dedicated
% algorithm float types and packages that provide these will not provide
% correct IEEE style captions. The latest version and documentation of
% algorithmic.sty can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/algorithms/
% There is also a support site at:
% http://algorithms.berlios.de/index.html
% Also of interest may be the (relatively newer and more customizable)
% algorithmicx.sty package by Szasz Janos:
% http://www.ctan.org/tex-archive/macros/latex/contrib/algorithmicx/

% *** ALIGNMENT PACKAGES ***
%
\usepackage{array}
% Frank Mittelbach's and David Carlisle's array.sty patches and improves
% the standard LaTeX2e array and tabular environments to provide better
% appearance and additional user controls. As the default LaTeX2e table
% generation code is lacking to the point of almost being broken with
% respect to the quality of the end results, all users are strongly
% advised to use an enhanced (at the very least that provided by array.sty)
% set of table tools. array.sty is already installed on most systems. The
% latest version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/tools/


\usepackage{mdwmath}
\usepackage{mdwtab}
% Also highly recommended is Mark Wooding's extremely powerful MDW tools,
% especially mdwmath.sty and mdwtab.sty which are used to format equations
% and tables, respectively. The MDWtools set is already installed on most
% LaTeX systems. The lastest version and documentation is available at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/mdwtools/

% IEEEtran contains the IEEEeqnarray family of commands that can be used to
% generate multiline equations as well as matrices, tables, etc., of high
% quality.

% *** SUBFIGURE PACKAGES ***
\ifCLASSOPTIONcompsoc
  \usepackage[caption=false,font=normalsize,labelfont=sf,textfont=sf]{subfig}
\else
  \usepackage[caption=false,font=footnotesize]{subfig}
\fi

%Setting captions to centered (Not IEEE journal standard)
%\makeatletter
%\long\def\@makecaption#1#2{\ifx\@captype\@IEEEtablestring%
%\footnotesize\begin{center}{\normalfont\footnotesize #1}\\
%{\normalfont\footnotesize\scshape #2}\end{center}%
%\@IEEEtablecaptionsepspace
%\else
%\@IEEEfigurecaptionsepspace
%\setbox\@tempboxa\hbox{\normalfont\footnotesize {#1.}~~ #2}%
%\ifdim \wd\@tempboxa >\hsize%
%\setbox\@tempboxa\hbox{\normalfont\footnotesize {#1.}~~ }%
%\parbox[t]{\hsize}{\normalfont\footnotesize \noindent\unhbox\@tempboxa#2}%
%\else
%\hbox to\hsize{\normalfont\footnotesize\hfil\box\@tempboxa\hfil}\fi\fi}
%\makeatother


% *** FLOAT PACKAGES ***
%
\usepackage{fixltx2e}
% fixltx2e, the successor to the earlier fix2col.sty, was written by
% Frank Mittelbach and David Carlisle. This package corrects a few problems
% in the LaTeX2e kernel, the most notable of which is that in current
% LaTeX2e releases, the ordering of single and double column floats is not
% guaranteed to be preserved. Thus, an unpatched LaTeX2e can allow a
% single column figure to be placed prior to an earlier double column
% figure. The latest version and documentation can be found at:
% http://www.ctan.org/tex-archive/macros/latex/base/

% *** PDF, URL AND HYPERLINK PACKAGES ***
%
\usepackage{url}

\usepackage{sistyle}
    \SIstyle{S-Africa}
    \SIunitspace{{\cdot}}
    \SIunitdot{{\cdot}}

% generate nice bookmarks and hyperrefs when exporting to pdf and dvi (screen version):
\usepackage[a4paper,plainpages=false,colorlinks,linktocpage,bookmarks=true,bookmarksopen=false]{hyperref}
% use this for printing only (no color, print version):
%\usepackage[a4paper,plainpages=false,colorlinks=false,linktocpage,bookmarks=true,bookmarksopen=false]{hyperref}

% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}

%List of acronyms used in text
 \usepackage{acronym}%.......................... Acronym package to handle acronyms in text

%Add elegant support for Big-O notation
\providecommand{\OO}[1]{\operatorname{O}\left(#1\right)}

\acrodef{MMOG}{Massively Multiplayer Online Game}
\acrodef{MMORPG}{Massively Multiplayer Online Role Playing Game}
\acrodef{WoW}{World of Warcraft}
\acrodef{MUD}{Multi-User Dungeon}
\acrodef{PvP}{Player-versus-Player}
\acrodef{P2P}{Peer-to-Peer}
\acrodef{CS}[C/S]{Client/Server}
\acrodef{CMS}[C/MS]{Client/Multi-Server}
\acrodef{NPC}{Non-Player Character}
\acrodef{aoi}[AoI]{Area of Interest}
\acrodef{alm}[ALM]{Application Level Multicast}
\acrodef{ui}[UI]{User Interface}
\acrodef{DHT}{Distributed Hash Table}
\acrodef{AoI}{Area of Interest}

\begin{document}

%
% paper title
\title{A Survey of State Persistency in Peer-to-Peer Massively Multiplayer Online Games}

\author{John~S.~Gilmore~and~Herman~A.~Engelbrecht% <-this % stops a space
\IEEEcompsocitemizethanks{\IEEEcompsocthanksitem J.S. Gilmore and H.A. Engelbrecht are with the MIH Media Laboratory at the Department of Electrical
and Electronic Engineering, Stellenbosch University, Stellenbosch, South Africa.\protect\\
% note need leading \protect in front of \\ to get a newline within \thanks as
% \\ is fragile and will error, could use \hfil\break instead.
E-mail: jgilmore@ml.sun.ac.za and hebrecht@sun.ac.za}% <-this % stops a space
\thanks{}}

\author{John~S.~Gilmore~and~Herman~A.~Engelbrecht% <-this % stops a space
\IEEEcompsocitemizethanks{\IEEEcompsocthanksitem J.S Gilmore is a PhD student with the MIH Media Laboratory at the Department of Electrical
and Electronic Engineering, Stellenbosch University, Stellenbosch, South Africa.\protect\\
% note need leading \protect in front of \\ to get a newline within \thanks as
% \\ is fragile and will error, could use \hfil\break instead.
E-mail: jgilmore@ml.sun.ac.za
\IEEEcompsocthanksitem H.A. Engelbrecht is the research manager at the MIH Media Laboratory at the Department of Electrical and Electronic Engineering, Stellenbosch University, Stellenbosch, South Africa.\protect\\
E-mail: hebrecht@sun.ac.za}% <-this % stops a space
\thanks{}}

% The paper headers
%\markboth{Draft Submission to the Journal of Parallel and Distributed Systems, July~2010}%
%{Draft Submission to the Journal of Parallel and Distributed Systems, July~2010}
% The only time the second header will appear is for the odd numbered pages
% after the title page when using the twoside option.

% The publisher's ID mark at the bottom of the page is less important with
% Computer Society journal papers as those publications place the marks
% outside of the main text columns and, therefore, unlike regular IEEE
% journals, the available text space is not reduced by their presence.
% If you want to put a publisher's ID mark on the page you can do it like
% this:
%\IEEEpubid{0000--0000/00\$00.00~\copyright~2007 IEEE}
% or like this to get the Computer Society new two part style.
%\IEEEpubid{\makebox[\columnwidth]{\hfill 0000--0000/00/\$00.00~\copyright~2007 IEEE}%
%\hspace{\columnsep}\makebox[\columnwidth]{Published by the IEEE Computer Society\hfill}}
% Remember, if you use this you must call \IEEEpubidadjcol in the second
% column for its text to clear the IEEEpubid mark (Computer Society jorunal
% papers don't need this extra clearance.)

% for Computer Society papers, we must declare the abstract and index terms
% PRIOR to the title within the \IEEEcompsoctitleabstractindextext IEEEtran
% command as these need to go into the title area created by \maketitle.
\IEEEcompsoctitleabstractindextext{%
\begin{abstract}
%\boldmath
Recently, there has been significant research focus on Peer-to-Peer (P2P) Massively Multiplayer Online Games (MMOGs). A number of architectures have
been presented in the literature to implement the P2P approach. One aspect that has not received sufficient attention in these architectures is state
persistency in MMOGs. This survey presents an overview of classic state persistency models used in C/S MMOGs, it then classifies the state
persistency techniques currently used in P2P MMOGs into super peer storage, overlay storage, hybrid storage and distance-based storage. Key
characteristics are also defined for a P2P MMOGs state persistency model and each state persistency technique is evaluated according to these
characteristics. An effort is also made to define metrics, by which the key characteristics may be measured. After the P2P MMOG state persistency
survey, a discussion follows on possible future avenues that may be investigated.

\textbf{Categories and Subject Descriptors}: C.2.4.b [\textbf{Distributed Systems}]: Distributed applications, J.8.g [\textbf{Internet
Applications}]: Games
\end{abstract}}
% IEEEtran.cls defaults to using nonbold math in the Abstract.
% This preserves the distinction between vectors and scalars. However,
% if the journal you are submitting to favors bold math in the abstract,
% then you can use LaTeX's standard command \boldmath at the very start
% of the abstract to achieve this. Many IEEE journals frown on math
% in the abstract anyway. In particular, the Computer Society does
% not want either math or citations to appear in the abstract.

% Note that keywords are not normally used for peer review papers.
%\begin{IEEEkeywords}
%A.1.0 [\textbf{Introductory and Survey}], C.2.d [\textbf{Distributed Systems}]: Distributed applications, J.8.g [\textbf{Internet Applications}]:
%Games
%\end{IEEEkeywords}

% make the title area
\maketitle

% To allow for easy dual compilation without having to reenter the
% abstract/keywords data, the \IEEEcompsoctitleabstractindextext text will
% not be used in maketitle, but will appear (i.e., to be "transported")
% here as \IEEEdisplaynotcompsoctitleabstractindextext when compsoc mode
% is not selected <OR> if conference mode is selected - because compsoc
% conference papers position the abstract like regular (non-compsoc)
% papers do!
\IEEEdisplaynotcompsoctitleabstractindextext
% \IEEEdisplaynotcompsoctitleabstractindextext has no effect when using
% compsoc under a non-conference mode.

% For peer review papers, you can put extra information on the cover
% page as needed:
% \ifCLASSOPTIONpeerreview
% \begin{center} \bfseries EDICS Category: 3-BBND \end{center}
% \fi
%
% For peerreview papers, this IEEEtran command inserts a page break and
% creates the second title. It will be ignored for other modes.
\IEEEpeerreviewmaketitle

\IEEEdisplaynotcompsoctitleabstractindextext

%\section{Introduction}
% Computer Society journal papers do something a tad strange with the very
% first section heading (almost always called "Introduction"). They place it
% ABOVE the main text! IEEEtran.cls currently does not do this for you.
% However, You can achieve this effect by making LaTeX jump through some
% hoops via something like:
%
\ifCLASSOPTIONcompsoc
  \noindent\raisebox{2\baselineskip}[0pt][0pt]%
  {\parbox{\columnwidth}{\section{Introduction}\label{sec:introduction}%
  \global\everypar=\everypar}}%
  \vspace{-1\baselineskip}\vspace{-\parskip}\par
\else
  \section{Introduction}\label{sec:introduction}\par
\fi
%
% Admittedly, this is a hack and may well be fragile, but seems to do the
% trick for me. Note the need to keep any \label that may be used right
% after \section in the above as the hack puts \section within a raised box.

% The very first letter is a 2 line initial drop letter followed
% by the rest of the first word in caps (small caps for compsoc).
%
% form to use if the first word consists of a single letter:
% \IEEEPARstart{A}{demo} file is ....
%
% form to use if you need the single drop letter followed by
% normal text (unknown if ever used by IEEE):
% \IEEEPARstart{A}{}demo file is ....
%
% Some journals put the first two words in caps:
% \IEEEPARstart{T}{his demo} file is ....
%
\IEEEPARstart{P}{eer-to-Peer (P2P)} Massively Multiplayer Online Games (MMOGs) have received a significant amount of attention from the research
community over the past years. Since the first publication on the subject by Knutssonn et al. \cite{knutsson_p2p_first}, the three areas of Interest
Management, Game Event Dissemination and Security, have received much attention from the research community, but the area of Game State Persistency
has remained mostly unexplored.

Interest Management determines how player actions are filtered to ensure that players only receive actions relevant to them, which reduces the
bandwidth requirements of the system. Game Event Dissemination entails how these events are then sent to various players. Security ensures that the
system is not affected by the activity of malicious peers.

Game State Persistency entails storing persistent game data in a distributed fashion in the the P2P network. Part of an MMOG is ensuring low latency,
consistent data persistency of all game data. Player data, in-game object states and \ac{NPC} states should all be stored.

This paper classifies the techniques used in documented P2P MMOG architectures and discusses the advantages and disadvantages of the different types
of storage. To the best of our knowledge, such a classification, where a focus is placed specifically on state persistency in P2P MMOGs, has not been
undertaken in the literature. As the field of P2P MMOGs is a growing one, it is believed that a comprehensive survey of persistency techniques is
required to act as a basis for further research into the field.

The survey will first introduce other surveys on the the topic of P2P overlay technologies and how these are different from this survey. After this,
an overview of classic models used in \ac{CS} and P2P multiplayer games is presented, in order to compare the classic models with the models used in
P2P MMOGs. P2P MMOG state persistency techniques are then classified in terms of the type of storage they provide and key characteristics are defined
by which the performance of these storages may be measured. The three identified types of storage are then described and evaluated according to the
key challenges, with references to the relevant work done in each field.

Section \ref{related_work} introduces other surveys in the field of P2P overlays and compares the surveys presented with this survey.
%
Section \ref{classic_network_models} introduces the two most common network models used in P2P MMOGs. The classic consistency models later defined
are based on the network models defined here, so an understanding of the advantages and disadvantages of each is essential.
%
Section \ref{classic_models} details how state persistency is handled in P2P, \ac{CS} and \ac{CMS} systems employed in multiplayer games today.
%
Section \ref{p2p_mmog_cm_overview} discusses how state persistency is implemented in P2P MMOGs by defining five key challenges and then discussing
three storage approaches according to the identified challenges.
%
Section \ref{eval_crit} attempts to define measurable metrics according to the key challenges to enable the comparison of the performance of
different state persistency models.

\section{Related work}
\label{related_work}

No papers were found that deal specifically with the subject of P2P state persistency in MMOGs, but some surveys were found that deal with other
issues of P2P MMOGs, or P2P overlays in general.

Krause presented ``A Case for Mutual Notification: A survey on P2P protocols for Massively Multiplayer Online Games.''
\cite{IM_and_ED_survey_Krause}. The protocols discussed in this survey focussed on the areas of interest management and event dissemination. Three
protocols were presented: ``Application Layer Multicast (ALM) based protocols'', ``Supernode based protocols'' and ``Mutual notification based
protocols''. The first two protocols deal with region-based interest management techniques that employ supernodes, also called super peers, and ALM
to achieve state consistency. The third protocol, which is presented as an alternative to region-based techniques, is a distance-based technique,
making use of Voronoi diagrams to achieve state consistency.

While the survey by Krause is also in the area of P2P MMOGs, it deals with the topics of interest management and event dissemination and not with the
topic of state persistency. In other words, it explains how updates to objects may be sent to earlier versions of an object, but not how these
objects may be stored.

Webb and Soh presented ``A Survey on Network Game Cheats and P2P Solutions'' \cite{survey_p2p_game_cheats}. The paper introduces a cheat
classification scheme, defining different ``levels'' of cheating, along with some examples of cheats in each level. For each example given, the
authors also discuss possible solutions to these cheats. The difference then, between this paper and the survey paper presented by Webb and Soh, is
their paper deals with securing the information stored in objects as well as securing updates made to objects, while this paper deals with storing
those objects.

%Amoretti's survey paper on P2P overlay schemes in general
Both of the previously mentioned articles deal with other issues present in P2P MMOGs, namely interest management, event dissemination and security.
The paper by Amoretti: ``A Survey of Peer-to-Peer Overlay Schemes: Effectiveness, Efficiency and Security'', provides details of the broader area of
P2P overlay schemes \cite{amoretti_p2p_overlay_schemes_survey}. The paper focuses on security issues present in P2P overlay schemes, while also
introducing hybrid, unstructured and structured overlays and provides an extensive list of applications of the different schemes in different areas.

Three areas present in Amoretti's survey and also related to this survey are: ``Content sharing'', ``distributed storage'' and ``gaming''. The
content sharing technologies described in Amoretti's work are considered forms of overlay storage, further discussed in Section
\ref{overlay_storage}. While Amoretti's survey gives a very broad description of P2P gaming in general and why it should be a viable alternative to a
C/S system, this survey deals specifically with the area of P2P MMOGs and more specifically, with state persistency in P2P MMOGs.

%Zhang's C/S persistency survey, describing when to perform which types of state updates.
%A paper recently published by Zhang et. al. deals with persistency in C/S MMORPGs \cite{zhang_cs_persistency_survey}. The paper investigates when
%game objects should be made persistent, i.e. written to secondary storage from primary storage. It distinguishes between data that should immediately
%be written to storage, such as an object changing hands in a trade, and data that only has to be written every other update, such as position
%updates. The paper then continues to define some schemes by which the number of position updates might be reduced as well as stating that MMOG
%persistence schemes are not widely published and are usually implementation specific.
%
%The paper by Zhang et. al. is related to this survey paper in that it looks at persistency and also provides information on what is required in a
%persistency scheme. The major difference between Zhang et. al.'s paper and this survey is that it deals with a C/S architecture and focusses on when
%to update objects, not where those objects will be stored.

\section{Classic MMOG network models}
\label{classic_network_models}

The network model specifies how the different entities in the network communicate, where authority lies and whether a centralised or distributed
approach is followed. The network model used determines how the different nodes in the network interact and what the roles of these different nodes
are. The consistency model used, is based on the network model, but determines how data are stored on the system as well as how root and duplicate
objects are kept consistent. The consistency model, therefore, includes the state persistency model.

Currently, all MMOGs being operated run on a \ac{CS} network model or a distributed \ac{CS} network model, also called a Client/Multi-Server (C/MS)
model. The simplest form of a network model used in MMOGs is the pure \ac{CS} model. Other games, such as strategy games and first person shooter
games regularly employ the peer-to-peer network model to achieve greater system responsiveness, as discussed in Section \ref{classic_cs_event_based}.

\begin{figure}[htbp]
\centering
 \subfloat[Client/Server]{\label{fig_cs_arch}
\includegraphics[clip=true, viewport= 0cm 12cm 11.5cm 21.5cm, width=0.5\columnwidth]{network_archs}}
\subfloat[Client/Multi-Server]{\label{fig_cms_arch}
\includegraphics[clip=true, viewport= 12cm 10.5cm 23cm 21cm, width=0.5\columnwidth]{network_archs}}
\caption{Network architectures}
\end{figure}

\subsection{Client/Server}
\label{client_server_network_model}

Figure \ref{fig_cs_arch} shows the \ac{CS} model. The server is the entity on which the MMOG is hosted and is controlled by the game operator.
Clients are computers operated by players, that connect to the server to play the game. The server is responsible for handling all queries from
clients. Clients never communicate with other clients; they send their actions to the server and receive the updated states of other players from the
server.

The \ac{CS} architecture has two main advantages that made it the architecture of choice for all MMOG developers. Because of the centralised approach
of the architecture, both administration and security are greatly simplified. Administration is simplified, because the game operator has full
control over the server, server data and code. Efficient logging is also supported, because the server is able to not only log all server actions,
but also all client actions.

Security is a significant issue in MMOGs, since some players sell in-game currency for real-world currency \cite{chinese_gold_farmer}. This makes the
MMOG a platform that is capable of producing income, which increases the incentive of players to gain an unfair advantage over others. The more
popular an MMOG, the greater the security threat. Because the operator has full control over the server code and is never required to furnish the
client with the server code, a potential attacker never has any knowledge of the server architecture and code. Because clients are never allowed to
communicate, all malicious users can be filtered out of the network by the server when detected and even banned from the network.

Operators are able to ban players, since these games usually require a game account, which is linked to a copy of the game as well as some payment
method. This introduces a large cost to players whose accounts are banned. The server or cluster is also housed in a secured location, where access
can be controlled. These factors simplify the security of the \ac{CS} model by allowing the developers to place all intelligence in the server.

The \ac{CS} architecture, however, does have some disadvantages. These are: weak robustness, weak scalability, high cost to the operator, high
latency, high amount of required server bandwidth and weak handling of transient loads. These disadvantages are described below.

The robustness of the system is weak because it is a single point of failure. If the server fails or goes down for maintenance, the game is off-line
and players are unable to play.

This system is also not scalable, since a single server cannot easily be extended with more resources. Even if an off-line approach is used, where
hardware is upgraded after the system is taken down for maintenance, the hardware required to support a game hosting more than 3000 players, become
prohibitively expensive. In 2004, it was estimated that an MMOG that supports approximately 30,000 players, requires 2 to 3 years to develop and
costs more than \$10 mil \cite{cs_mmog_cost}, \cite{igda_online_whitepaper}. With newer games using high definition graphics and the general drive in
the market to improve on previous titles, the cost of MMOG games can only be expected to increase.

The server hardware should be able to support peak system loads, which means that sufficient resources should always be provisioned to support these
peak load. This is not an economically viable solution, because resources to handle peak loads are not used most of the time. This translates to
operators paying for the provisioning of resources, without having active players that pay for these resources.

This disadvantage also leads to a high cost to the operator, which translates to high costs for clients or reduced profit. The cost is due to the
hardware that is required to host the system as well as maintenance and running costs. Running costs include bandwidth provisioning and IT personnel.
Maintenance costs include replacement of malfunctioning or outdated hardware. It has been estimated that maintenance and running costs consume
approximately 80\% of game revenue during the lifetime of the game \cite{cs_mmog_cost}.

Because no clients are allowed to communicate with other clients, every change that is made to the game world by a client, first had to be
communicated to the server, which in turns relays this message to all clients after applying game logic and artificial intelligence (AI) algorithms.
This two hop path, with the additional time for computation added by the server as well as possible buffering at the server when many clients
communicate, significantly increases the latency of the system compared to a system where direct communication is used.

\subsection{Client/Multi-Server}
In an effort to address some of the \ac{CS} issues, the distributed \ac{CS}, also called \ac{CMS}, was introduced. In a distributed \ac{CS} model,
the server functions are distributed amongst multiple machines to distribute the server load. The server functions can be distributed by means of
redundancy or specialisation. In a redundant system, server functions are duplicated. In a specialisation system, different server functions are
handled by different distributed servers.

In general, the issues addressed and improved by the \ac{CMS} architecture are robustness, scalability, and peak load handling. The system is more
robust, because the failure of one server will not necessarily lead to the failure of the whole system for certain system designs. The system is more
scalable, because many less powerful servers may be used, which allows for the hosting of more players than what is currently possible with single
server hardware. It also handles transient loads better, because, for cases where loads can be predicted, resources can by moved between servers to
improve the user experience.

The disadvantages of this system is that the administration complexity is greatly increased. Such systems, although capable of handling many more
users than a single server, is also much more expensive. These disadvantages are, however, not technical problems and so it is assumed for current
games, that these systems are what is required if a game is to be hosted for a large number of players.

\section{Classic consistency models}
\label{classic_models}

A consistency model is based on the network model, but deals with how data are stored and distributed throughout the system. Usually a game object
exists in two forms. The root object and the replica object. Root objects are the objects traditionally housed on the Server in the C/S based MMOGs.
All clients obtain replicas of these objects and duplicate them locally in order to perform low latency computations with these objects. An example
would be an NPC monster. When the players perceive the monster in the virtual world, a duplicate of the NPC objects is sent to the user's computer
for display purposes. When another player attacks the NPC, the change in health will be computed at the server and an update is then sent in order to
ensure consistency between the root objects and the replica object.

To understand consistency models, some basic terms should first be understood. These terms are: ``event'', ``update'', ``game state'', ``game logic''
and ``game object''.

\emph{Events:} Events are generated by players and can be thought of as actions taken by players. These include casting a spell, using an item
    or walking.

\emph{Game Logic:} Game logic is applied to events to determine what updates should be applied to the game state. Game logic is thus a
    ``think'' function, which determines how the world should change as a result of an event. Another way to think about game logic is to see
    it as the game rules. A player casting a spell might cause another player's health to be reduced, her own health to be increased or a
    monster to spawn. When a player is walking, the logic will cause the player's position to update at the player's walking speed.

\emph{Update:} Game logic communicates how the world should change via game updates. Game updates are the incremental changes that specify how
    the game state should change.

\emph{Game State} The state of the game is the positions, health and all other attributes of all players, \acp{NPC} and game objects in the game
    world. Game state consists of a collection of game objects. An \ac{NPC} as well as an immutable plant are both examples of game objects that
    together make up the game state.

\emph{Game objects:} When discussing how to segment game state, it is sometimes easier to speak in terms of game objects, since they are
    separable. For the purposes of this work, game objects are objects with both state and logic, which means they consume both storage
    space, as well as CPU power. Game objects can also produce events, which should be sent to other objects. When this definition is used,
    NPC objects may be classified as a specific type of a game object, which forms part of the global game state. The question of NPC hosting
    then also becomes a question of state persistency.



\subsection{P2P and C/S consistency models}
\label{p2p_cs_models}

As an introduction to consistency models, an overview of the two common models, currently used in computer games will be described. The models used
in P2P MMOGs are all permutations of these two basic models. The two models are based on the two different network models. These are the P2P-based
model, also called the event-based model \cite{p2p_cm_aoe}, and the \ac{CS}-based model, also called update-based model \cite{unreal_networking}.

\subsubsection{Event-based (P2P)}
\label{classic_cs_event_based}

\begin{figure*}[htbp]
\centering \subfloat[Event-based (peer-to-peer)]{\label{fig_p2p_cm}
\includegraphics[clip=true, viewport= 2.5cm 0.5cm 19cm 15cm, width=\columnwidth]{CS_P2P_CMs}}
 \subfloat[Update-based (client/server)]{\label{fig_cs_cm}
\includegraphics[clip=true, viewport= 2.5cm 15cm 19cm 30cm, width=\columnwidth]{CS_P2P_CMs}}
\caption{Consistency models}
\end{figure*}
%
Figure \ref{fig_p2p_cm} shows the P2P model. In this model the complete game state is stored on each peer. Any event that a peer generates is sent to
all other peers. These events are used as inputs to the game logic, which creates updates, which are then used to update the global game state at
each peer.

It is at this level that consistency becomes important. The order in which updates are received should be the same for all peers, otherwise the game
states of different peers may become inconsistent. Usually some kind of lockstep technique is used to solve this issue \cite{pessimistic_lock_step}.
The issue with lockstep is that it reduces the latency to twice that of the peer with the highest latency. Various techniques have been proposed that
improves the latency by introducing some deadline before which all events should be submitted \cite{cheat_proof_event_ordering}. This, however, makes
it impossible for a player with a high latency to play the game with anyone other than from her own continent. When latencies issues are not present
and all players possess reasonable latencies, the event-based model can provide for an high-degree of responsiveness, because of no extra latency
being added by a server and no extra server hop required for communications.

The issue with the event-based model is that it is not scalable, since all peers should connect to all other peers and every event is transmitted to
everyone. This means that as $N$, the number of peers in the network, increases, the amount of traffic increases with a factor of $N^2$. The security
issues of the P2P network model, on which this consistency model is based, are also present. Slowdown is also experienced by all players if one
player's latency is below par, since the lockstep mechanism has to wait for all events to be received for that round to conclude.

\subsubsection{Update-based (C/S)}
An alternative to the event-based model is the update-based model, shown in Figure \ref{fig_cs_cm}. This model is based on the Client/Server network
model. An authoritative global game state is housed on the server and a non-authoritative local game state is housed on all clients for display
purposes. No real game logic is housed at the clients, only on the server. All clients send events to the server, which applies the game logic and
sends updates to the clients, while also updating its own game state.

This approach greatly assists with security, as clients cannot influence the state of any other clients and every client's state depends on updates
received from the server. The server state is also termed authoritative, because if there is a conflict, the server state is always the state to
which the system is expected to return. All the security advantages of the \ac{CS} model also apply to this consistency model. Another reason why the
update based model is successful is because it is more scalable then the pure P2P model. More hardware can be used to build a more powerful server,
which can handle more clients. This is however very costly as discussed in Section \ref{client_server_network_model}.

\subsection{Client/Multi-Server consistency models}
\label{cms_models}

%Should I add diagrams here?

Apart from the two classic models, there are also models based on the \ac{CMS} network model, which are: shard-based, replication-based, object-based
and zone-based \cite{Hu_voronoi_IM}.

\subsubsection{Sharding}
Sony introduced the first consistency method for a \ac{CMS} network in Everquest, where copies of the game world ran on different servers and players
connected to one of these servers \cite{engineering_everquest}. Sony termed this method: ``Sharding''. Clients are not able to interact or
communicate with players on other shards, which reduces game immersion. This method does, however, allow for a more scalable system as maximum load
is fixed.

Players are not able to enter a shard if that shard has reached it capacity. This has in the past caused unhappiness amongst players, since popular
shards could be difficult to log in to. Players are also reluctant to move to a new shard, because a lot of time is invested in their characters in
their ``home'' shard. Sharding doesn't allocate resources efficiently, as one shard may be overpopulated while another is underpopulated. There is no
way to dynamically distribute the available resources from one shard to another. For all practical purposes, this approach is still merely a \ac{CS}
approach, with players forced into a specific \ac{CS} environment.

\subsubsection{Replication-based}
%Redundant
The replication-based model is very similar to sharding, with the difference that all servers share the same duplicated game state. Each server
contains the global game state and clients connect to any one of these servers (mirror-servers \cite{mirrored_server}) or through a load distribution
algorithm to a server (proxy-servers \cite{proxy_server_dist}). Each server handles all actions from clients and updates its own database. The
servers in turn send updates to each other over a high quality link, such as fibre, to maintain database consistency at high speeds.

The problem with this system is that the world is never truly consistent and that there are no optimally chosen inconsistency obfuscation boundaries.
In other words, two players standing next to each other in the virtual world, might be on different servers and, therefore, experience two slightly
different worlds.

\subsubsection{Object-based}
%Object based
The object-based method distributes all in-game objects amongst the servers \cite{object_based_consistency1}, \cite{object_based_consistency2},
\cite{object_based_consistency3}. For an MMOG, most of these objects are expected to be player objects. The advantage of this method is that the
system load is fixed for a certain player population and that the load is equally distributed amongst all servers. This allows for more accurate
prediction and provisioning of resources, but still does not handle transient loads well.

Another issue is inter-server communications for this architecture. The inter-server communications are random and also much more than the
inter-server communications for a region based system. The reason for this is that the amount of player interaction increases with a decrease in the
distance between the players. Players playing together move together, chat and interact with \acp{NPC} together. For a region based model, all
player-neighbour interactions remain local to the server.

\subsubsection{Zone/Region-based}
%Zone-based
The zone-based method divides the virtual world into zones or regions, which are hosted on different servers \cite{zone_based_stat},
\cite{zone_based_dyn}. Busy regions are hosted on their own servers, while multiple quiet regions are hosted on a single server. This is termed the
static region approach \cite{zone_based_stat}. The issue of the static region approach is that it does not scale well when one region is suddenly
populated with players. This type of behaviour happens quite regularly and is known as flocking \cite{flocking}.

When players find something of interest in a region, many players will flock to that region. In-game events and festivals are also becoming popular
and these events also cause flocking to the region where the event is held. The solution to these effects have been over provisioning of resources to
handle peak loads, which suffers from the disadvantages discussed above. Also, if the load changes, the server has to be brought off-line in order to
balance the regions.

Dynamic regions are being investigated, where regions can be dynamically shifted from one server to another, in order to balance load
\cite{zone_based_dyn}. This approach adds overhead and significant complexity with regards to the migration of the data and the handling of player
actions while the data are in transit.

\section{Peer-to-Peer MMOG network models}
\label{p2p_network_models}

In 2004, an architecture using the peer-to-peer networking model to host MMOGs gained popularity \cite{knutsson_p2p_first}. This revealed a new
research field, which attempts to establish the peer-to-peer model as a viable alternative to the classic \ac{CS} and \ac{CMS} architectures. This
architecture does, however, still have a few major issues that need to be solved before MMOGs can be developed that use it. If these issues,
discussed in Section \ref{key_challenges}, can be solved, a \ac{P2P} architecture holds some powerful advantages over a \ac{CS} system.

The core idea of the \ac{P2P} model is that each peer contributes sufficient resources to the network to host itself. This also means that all
functions of the server in the classic \ac{CS} model are distributed amongst all peers. There are many areas where the \ac{P2P} model can improve on
the classic \ac{CS} model. These areas are robustness, scalability, provider cost, latency, server bandwidth and handling of peak transient load.

\subsection{Advantages}

The system is very robust, because there is no server that can fail, only individual peers. Individual peers failing will not affect any other peers
other than the peer that failed. This behaviour makes game down-time extremely unlikely.

Furthermore, because every peer hosts itself, the system is scalable. Another advantage is that no extra costs are incurred from an operator
perspective, for any peer that joins the network. This will also allow for efficient handling of transient loads. If many players suddenly enter the
game, no resource provisioning issues will arise, as peers already possess their required resources.

It should also be noted that it is not at all unreasonable to assume that a peer will have sufficient resources to host itself. Peer computers are
very powerful systems these days, with multi-core CPUs, multiple gigahertz of clock speeds, multiple gigabytes of memory and secondary storage space
in the terabyte range. The graphics cards in gaming machines have also become immensely powerful.

\ac{P2P} architectures also create a lot of opportunity for independent developers, because a large initial investment is now no longer required to
purchase the expensive server hardware. Not just are hardware costs greatly reduced, but running costs are also greatly reduced. The bandwidth
required by the game server is now shared amongst users. Which means that no bandwidth costs will be incurred by the provider.

Latency is also improved, because it is now possible to directly communicate between peers and not necessary to communicate via a server. There is
also no single server that has to process peer actions. Peer actions need only be processed by other peers who find the specific peer actions of
interest. The distribution of the load as well as direct communication will further reduce latency.

\subsection{Challenges}

There are, however, challenges with administration and security. From an administrative perspective, it is more complex to administer a decentralised
system than a centralised one. For a peer-to-peer system, the server is the collection of all peers. The game producer does not have direct access to
peers and so controlling these nodes become significantly more complex. P2P security issues also stem from the decentralised nature of the system and
the fact that an attacker has full access to all system code. These issues are discussed in more detail in Section \ref{key_challenges}.

Another challenge for P2P systems is the required peer bandwidth. In a paper by Miller and Crowcroft, a packet simulator was created to determine the
amount of required bandwidth and effective latency, if a game such as World of Warcraft were to be implemented using P2P technologies
\cite{Miller_p2p_infeasability}. What was found, using their simulator, is that today's networks are not yet able to host P2P MMOGs, with the
required bandwidth and latency constraints. Such a significant result still bears repeating, but at the least, it shows that reducing bandwidth and
latencies for P2P MMOGs should be a primary design requirement.

Table \ref{tab_archs} summarises the differences between the three architectures as discussed thus far. From this architecture and the previous
discussion, it can be seen that the P2P architecture has a lot of advantages over a classic C/S architecture, but that there are challenges that have
to be addressed. These include ways to administer the system when there is no centralised form of control, security issues arising from the
decentralised nature of the architecture and the required P2P bandwidth and latencies.
%
\begin{table*}[htbp]
\centering
\begin{tabular}{|r|c|c|c|}
\hline
Property & Client/Server & Client/Multi-Server & Peer-to-Peer\\
\hline
Administration & Low & Medium & High\\
Security & High & High & Low\\
Robustness & Low & Medium & High\\
Scalability & Low & Medium & High\\
Provider cost & High & Very high & Low\\
Latency & High & High & Low\\
Server bandwidth & High & High & None\\
Peer bandwidth & Low & Low & High\\
Peak transient load handling & Bad & Medium & Good\\
\hline
\end{tabular}
\caption{Differences between Client/Server, Client/Multi-Server and Peer-to-Peer architectures} \label{tab_archs}
\end{table*}

%TODO: Add description of table here

\subsection{Structured and unstructured P2P overlay networks}
\label{overlays}

P2P networks create applications layer networks, called overlay networks. Peers in an overlay network have neighbours that might have no relationship
to their physical neighbours. Overlays can broadly be classified into structured and unstructured types. The classification is mostly based on the
differing methods of routing and content retrieval in the network. This section only provides a brief overview of the subject. For a detailed
comparison between structured and unstructured overlays that also deals with many of the myths of structured overlays, please refer to
\cite{Castro_structured_overlay_myths}.

Unstructured approaches generally make use of flooding or random walk routing techniques to obtain data items, which means that one is never assured
that a data item will be retrieved, even if that data item is present in the network. If many duplicates of a data item is contained in the network,
this becomes less of a problem, since it is assumed that the request will be routed to some set of nodes that possess the item.

An unstructured architecture works well for content sharing networks, for example: BitTorrent and Gnutella. The reason for this is the high level of
duplication in these networks, especially for popular content. It is also easier to perform keyword searches in unstructured networks and the overlay
requires less maintenance. It should be noted that the perceived defects in structured overlays were actually implementation specific. Another
structure might be chosen, which mimics the architecture of the unstructured network, which does support complex queries, requires a low amount of
maintenance and improves the efficiency of the unstructured routing protocols \cite{Castro_structured_overlay_myths},
\cite{Castro_structured_gnutella}.

The use of flooding and random walk routing make unstructured overlays an unreliable option for use with P2P MMOGs. Structured overlays have been
proposed that provide for efficient routing. Some of these well known overlays are: CAN \cite{CAN}, Chord \cite{chord}, Tapestry \cite{tapestry} and
Pastry \cite{pastry}. The overlay most used in P2P MMOG systems is Pastry, as Scribe \cite{scribe}, which implements Application Layer Multicast,
runs on top of Pastry.

The basic idea of a structured overlay is that all nodes are identified by unique IDs, which are hashes to a circular key space. Any node in the
overlay network is then able to efficiently route a query with a given ID, to a node with an ID closest to the given ID.

Classically, it has been said that unstructured overlays are good at finding ``hay'', while structured overlays are good at finding ``needles''
\cite{Rodrigues_acm_comms_p2p}.

Since the introduction of overlays, they have been employed for various tasks. One task is simple message routing, but on top of the routing layer,
many other services have been implemented. These include \ac{alm}, distributed storage \cite{past_storage_focus} and indexing. \ac{alm} requires the
presence of a structured tree to send messages over. Implementations such as Scribe use the Pastry overlay to form a multicast tree over the
structured network overlay.

\subsection{Key challenges}
\label{key_challenges}

A recent article has identified six key challenges of P2P systems: Interest Management, Game Event Dissemination, NPC Host Allocation, Game State
Persistency, Cheating Mitigation and Incentive Mechanisms \cite{Fan_deisgn_issues_p2p}. A brief overview of these challenges will be introduced
below. It should be noted that the overview presented here is just that, an overview of the different techniques and general trends present in the
different areas of peer-to-peer MMOGs. This overview does not presume to present an exhaustive list of papers in these areas, rather to place the
topic of state persistency in context; to show readers how state persistency fits into the context of peer-to-peer games and to allow readers to
distinguish between, for example, the topics of state persistency, interest management and event dissemination.

%Some key requirements have also been identified. These requirements stipulate what characteristics an MMOG should poses, to be classified as such.
%These are: Distribution, Consistency, Self-Organisation, Persistency, Availability, Interactivity, Scalability, Security, Efficiency,
%Maintainability \cite{Schiele_p2p_requirements}.

%Describe key requirements

%Describe key challenges
\subsubsection{Interest management}
\label{key_challenges_im}

Interest management is used to determine the smallest amount of information that a peer requires, in order to present an accurate representation of
the world to each player. The idea is not specific to P2P MMOGs and was already formally put forward in \cite{First_IM} and later with greater focus
on a distributed environment in \cite{Whang_agent_based_IM}.

The main idea is that a player has a limited visual range and a limited area around the player in which it can interact with objects. The player
requires update information of all objects in this area, called the player's \ac{aoi}. AoI calculations also rely on the fact the a player's
direction and velocity of movement cannot change instantaneously and are bounded.

Extensive research has been done into solving AoI problems and a comparison of techniques can be found in \cite{Boulanger_IM_compare} and
\cite{IM_and_ED_survey_Krause}. The solutions range from aura/nimbus \cite{Benford_spatial_IM} to publish/subscribe \cite{mercury_publish_subscribe}
to Voronoi based models \cite{Hu_voronoi_IM}, \cite{Buyukkaya_voronoi_state_management} to hybrid models \cite{hybrid_IM}, \cite{MOPAR},
\cite{fan_mediator_paper}.

Generally, interest management solutions can be divided into coarsely or finely grained solutions, although the hybrid models, especially MOPAR, seem
to have gained greater popularity because they seem to have all the benefits of the two solutions and little of the drawbacks \cite{MOPAR}. MOPAR has
been shown to perform better than either a finely grained technique or a coarsely grained technique.

Coarsely grained solutions usually divide the game world into multiple regions and when a player enters a region, it subscribes to that region's
events. This is called the region-based publish subscribe model \cite{Fan_deisgn_issues_p2p}. All players in the region then receive the region's
events, even for players not in their AoI.

Finely grained techniques create groups of players from their \acp{aoi}. Groups of interacting players directly exchange information, so all players
only receive information that is relevant to them. This has been termed the spatial model \cite{Fan_deisgn_issues_p2p}. The grain of the solution in
turn determines the type of event dissemination that should be used, as described later in this section.

Another example of finely grained interest management was presented in \cite{IM_frontier_sets}. Interest management was achieved by making use of
frontier sets and this was implemented in Quake 3. By using Frontier Sets, it is possible to describe an area in which a player may move, where no
other players will require updates of that movement. Conversely, a set of other players that require movement updates from a specific player is also
given by the frontier set.

MOPAR partitions the game world into hexagonal regions and appoints ``home'' nodes to act as bootstrap nodes for each region. A home node of a region
is that node whose ID is the closest match the the region ID. This allows any node to find the home node for a region. A master node is then selected
for every region, whose function it is to inform slave nodes of new neighbours. All slaves nodes in a region register at their region's master node.
Slave nodes send direction and velocity updates to their masters. Masters communicate directly with other masters if a node is about to enter their
region. Masters inform their slaves of a new neighbour. Slaves communicate directly with each other, once identified by a master.



%The issue with the finely grained model is scalability. As nodes join, the number of messages increase quadratically, as previously mentioned.
%This means that in highly populated regions, too many messages are sent to nodes which can increase latency to unmanageable levels. Highly populated
%regions will however experience the same issues if no dynamic regioning is implemented.

%Event Dissemination
\subsubsection{Event dissemination}
Event dissemination deals with how information should be sent to peers after interest management has determined which information should be sent. The
first application of event dissemination for online games can be found in \cite{first_GED}. Recently, \ac{alm} and unicast techniques of event
dissemination have become popular, depending on the grain of the event dissemination. \ac{alm} is used, instead of router level multicast, because of
a lack of general support for this technology at the router level \cite{ip_multicast_deployment_issues}.

ALM is used for coarsely grained interest management techniques, while unicast is used for finely grained techniques. Unicast is not used for
coarsely grained techniques, because it is not scalable. For a network with $N$ nodes, $N^2$ messages are exchanges for every player action. ALM,
however, significantly increases the message latency in the system, because messages first have to be routed over a structured overlay network. ALM
is however preferred over unicast for large numbers of messages, because of the weak scalability of unicast.

An ALM scheme has recently been proposed, that sends updates to locations in the virtual world, rather than specific players
\cite{Ghaffari_Delaunay_churn_mobility}. This removes the need to first determine which nodes will be affected by an event, before the event may be
transmitted. Another ALM scheme proposed sends messages to the AoI neighbours, instead of to all the players in the region
\cite{Seeger_area_based_gossip_multicast}. This effectively implements a basic interest management scheme, where only neighbouring players can
receive events.

%Cheating Mitigation
\subsubsection{Cheating mitigation}
\label{key_challenges_cheating}

Cheating mitigation has been identified as a major issue for P2P systems \cite{knutsson_p2p_first}, \cite{challenges_p2p_gaming},
\cite{cheat_proof_event_ordering}. The challenges reside in the fact that peers are not under the control of the game producer. Since all server data
are distributed amongst peers, all peers have access to sections of the server data. Peers also have access to the distributed server code. One
advantage that can be exploited to prevent cheating is that no peer contains all server data and no one peer has more authority than another.

There are various security issues and these are usually divided according to the level of the protocol stack where they occur. The areas that have
been identified by \cite{cheat_proof_event_ordering} and expanded upon by \cite{cheating_taxonomy} are: game level, application level, protocol level
and infrastructure level. This is consistent with the generally used layered security model \cite{distributed_systems_security}. Game level cheats
are ways in which a malicious player may gain an unfair advantage over other players, within the confines of the game. These cheats are usually
because of software bugs and some examples are duplication and teleport cheats.

Application level cheats are where malicious players alter the game software to gain an unfair advantage. This is usually done by gaining access to
the game state to which they should not have access at the current time. An example of this is ``map reveal'' cheats in strategy games. Where the
``fog of war'' is removed and the player can observe all the opponent's movements. Other cheats are sometimes used that augment the player's \ac{ui}
with extra information that allows the player to make more informed decisions. It is debatable whether these additions are cheats. They are, however,
considered almost essential for competitive \ac{WoW} play.

Protocol level cheats are cheats based on the different methods of communicating data across the system. These usually concern dropping, delaying of
modifying IP packets to achieve certain outcomes in the game. Infrastructure level cheats concern exploiting the underlying infrastructure on which
the games are built. These include hacking the hardware or P2P overlay.

As with all taxonomies, all cheats may not cleanly fit into one if these boxes, some cheats may occur over multiple levels or a cheat with a specific
outcome can be implemented differently on different levels. The field of P2P security has recently received more attention than in the past and has
started to bear fruit \cite{survey_p2p_game_cheats}. This is, however, an ongoing research field with many issues still open. For an in-depth review
of the security issues facing peer-to-peer system in general, refer to \cite{p2p_security_issues}. These issues are the same issues facing P2P MMOGs,
with the exception of the game and application layer issues.

\subsubsection{Incentive mechanisms}

P2P schemes require all players to share resources in order to ensure that the system functions correctly. The issue with this is that players are
people who might not want to share their resources, but still benefit from the resources of others. This is where incentive mechanisms become
important. The function of these mechanisms is to ensure that all players contribute resources, by incentivised contribution.

All distributed resource sharing models require incentive mechanisms. Bittorrent systems for example use the tit-for-tat protocol \cite{tit_for_tat}
to ensure that all people downloading data are also contributing data. Such mechanisms are also required with P2P MMOGs. Peers playing a game should
be incentivised to contribute resources to the system. One advantage in designing an incentive algorithm for a P2P MMOG is that players can be made
to contribute resources for the duration of play. The issues with file sharing systems are not present where a peer, after downloading a file, has no
more incentive to contribute. When a peer plays a game, incentive can be created to provide resources for the duration of the game.

Some incentive schemes proposed increase a player's reputation when resources are provided \cite{classic_p2p_reputation} \cite{proactive_reputation}.
This might create a type of meta game, where players try to gain as much reputation as possible. It can however be argued that this scheme does not
really enforce the provisioning of resources. A player who does not want to provide resources might not see a higher reputation as sufficient
incentive to provide resources.

Other issues with incentive schemes is that sometimes players might have insufficient resources. Such players should be aided by other players with
sufficient resources and not be disallowed to play the game. When limited resources are taken into account, the issue of reporting a false amount of
available resources becomes a problem. A peer that has sufficient resources, might report insufficient resources, to not be penalised. It is evident
that there exists space for more research in this field.

\subsubsection{Game state persistency}

The issue of game state persistency will be dealt with in detail in the rest of the paper, since it forms the focus of this work. Game state
persistency involves the storage of game objects, either in primary or secondary storage. Lu Fan in Section 3.5.3 of a recently completed PhD on the
topic of P2P MMOGs had this to say about state persistency: ``Game state persistency is a major challenge for P2P MMOGs as existing P2P storage
infrastructures are designed to support file sharing, and seldom fulfil the performance and security requirements of a MMOG. \ldots the persistency
area is still immature with many problems waiting to be investigated.'' \cite{Fan_phd}.

\subsubsection{Distributed computation}

Some changes were made to the original classification by Fan relating to NPC host allocation. In the original NPC host allocation classification,
both NPC state and computational routines are combined into a single category. In the classification presented below, NPC state forms part of normal
game state persistency, since NPC objects are game objects like any other. The NPC routines requiring computational power are grouped under the
heading of distributed computation. This heading is meant to include the distribution of all in game computational elements.

Some game objects require computational power to function. An example of this is the Artificial Intelligence routines of \acp{NPC} or the computation
of physics effects on in-game objects. Some architectures assume that the computational requirements will be fulfilled where the object state is
hosted \cite{solipsis}, but other schemes exist that allows for the CPU power to be distributed amongst peers. One such scheme makes use of a ``job
board'' like mechanism, where tasks are advertised on specialised super peers. Other peers monitor these super peers and may elect to perform the
advertised tasks \cite{fan_mediator_paper}.


\section{P2P MMOG consistency models}
\label{p2p_mmog_cm_overview}

%Overview of three approaches
Very little work has been done on state persistency for P2P MMOGs. Generally four approaches have been identified to achieve state persistency:
\emph{super peer storage}, \emph{overlay storage}, \emph{distance-based storage} and \emph{hybrid storage}. These four storage architectures are
detailed in Sections \ref{super_peer_storage}, \ref{overlay_storage}, \ref{hybrid_storage} and \ref{distance_based_storage}.

%Individual storage
Two other types of storage sometimes described in P2P MMOGs papers are \emph{centralised storage} and \emph{individual storage}. Centralised storage
is storage in a centralised database, the same as for a C/S MMOG \cite{badumna_engine}, \cite{rooney_centralised_storage},
\cite{hybrid_p2p_cs_centralised}. Centralised storage for a MMOG requires the same large expensive servers and high bandwidth amounts, required by a
classic C/S architecture and therefore does not fit into the P2P MMOG paradigm. For this reason, centralised storage will not be evaluated in this
paper.

Furthermore, in the P2P MMOG papers that use centralised storage, no motivation is given for using this storage. These papers focus more on interest
management, event dissemination or security, and one can only assume that the use of centralised storage is more out of convenience than any real
consideration for its function in the P2P system.

%Centralised storage
The same assumption can be made of individual storage. With individual storage, player data are stored on a player's own computer
\cite{individual_storage1}, \cite{cheat_proof_playout}. In these architectures, no thought is given to the storage of NPC state or mutable objects.
These objects cannot be as easily mapped to a single node in the network as player state can and therefore require a mapping mechanism to decide
where to host these objects.

Another issue with individual storage is that of security. If all information about a player's character is hosted on that player's computer, there
exists significant incentive for cheating. It would be possible for a malicious user to gain access to his own data and manipulate that data for self
benefit. For example: to give himself more experience, health or mana than what he should possess, or to provide him with more powerful items than
what he already possesses. For these reasons, individual storage will not be explicitly discussed in this survey, however, individual storage can be
regarded as a subset of distance-based storage, which will be discussed in detail in Section \ref{distance_based_storage}.

\begin{table*}[htbp]
\centering
\begin{tabular}{|r|c|c|c|c|l|}
\hline
Storage type & Reliability & Responsiveness & Security & Fairness & Examples\\
\hline
Super Peer & Medium & High & Low & Low & \cite{knutsson_p2p_first}\\
Overlay & High & Low & Medium & High & \cite{Douglas05enablingmassively}, \cite{using_freenet_storage},
\cite{Fan_phd}, \cite{past_storage_focus}\\
Hybrid & High & High & Low & Low & \cite{zoned_federation}, \cite{hybrid_storage1}\\
Distance-based & Low & High & Low & High & \cite{Buyukkaya_voronoi_state_management}, \cite{Hu_voronoi_IM},
\cite{colyseus_distance_based}, \cite{solipsis}\\
\hline
\end{tabular}
\caption{Differences between storage mechanisms} \label{tab_storage}
\end{table*}
%
Table \ref{tab_storage} presents a characterisation of current storage systems according to the characteristics defined in Section
\ref{key_challenges_cm}. From this table it can be seen that no one storage mechanism has fully addressed all the identified issues. What is also
shown is that architectures that differentiate between different types of data, are theoretically better suited to the MMOG application. The example
of such an architecture is the hybrid architecture, which also seems to fare best, when compared to other storage techniques. Table \ref{tab_storage}
also provides some references that act as examples of the different storage types mentioned. These example architecture will be discussed in detail
in the sections to follow.

\subsection{Characteristics}
\label{key_challenges_cm}

%Consistency issues
The key challenges related to P2P MMOG consistency models identified during this literature study were: scalability, reliability, responsiveness,
security and fairness. All state persistency models will be reviewed with these characteristics in mind. In order to evaluate any consistency model,
metrics have to be defined to measure the key characteristics of a storage system. This will allow for different consistency models to be compared
and provide a measure of the applicability of any consistency model to P2P MMOGs. Such metrics could also compare the performance of one storage
architecture to another.

\subsubsection{Scalability}
Scalability underpins all evaluation criteria. This implies that for a system to be scalable, all other evaluation criteria should be satisfied for
very large numbers of nodes and data. The question of what constitutes a large number of nodes arises. To establish what an adequate number of nodes
is, current MMOG architectures can be used for inspiration.

It is put proposed that to classify a system as \emph{sufficiently scalable}, the smallest number of peers that should be used is approximately 3000.
This is the number of players per server, currently supported by most active C/S MMOGs. For a system to be classified as \emph{truly scalable}, it is
believed that the architecture should support 60,000 concurrent users, twenty times more than a sufficiently scalable system. This is the number of
peak concurrent users (PCUs) currently supported by the super computer used to host Eve Online \cite{eve_pcu}. These two measures will ensure that a
system is as scalable as other currently available architectures.

For systems that will support the MMOGs of the future, it is believed that a target of 1 million nodes should be used. This number is sixteen times
that of a truly scalable system and the peak concurrent player count of World of Warcraft in China in 2008 \cite{WoW_china_pcu}. Systems that will
support these numbers can be classified as \emph{highly scalable}. It is important to note that no current systems support such a large PCU count on
a single server cluster. The PCU count presented for WoW is the PCU count over all server clusters hosting WoW in China.

\subsubsection{Fairness}
Ensuring fairness in the system means distributing load evenly according to the abilities of individual nodes. This ensures that not only a small
number of nodes provide all system resources required for the system to function, but that all nodes contribute what they can, in order to support
the system.

Fairness can be evaluated by evaluating the distribution of game state amongst all nodes in the P2P network. This can be measured at a file level,
i.e. what is the variance of the number of files contained on each node, or on byte level, i.e. what is the variance of the number of bytes stored on
each node. A lower variance will point to a fairer data persistency scheme.

\subsubsection{Reliability}
For the storage to be reliable, it must be impossible for data to be lost, and stored data should always be available when a node requests it.

Reliability encompasses both robustness and availability. Robustness means that the data should be resilient to network churn and availability means
that data should be available to any node in the network, with the correct permissions. To measure robustness, nodes have to leave the network at
different rates and the loss of storage for different rates of churn have to be measured.

It can then be determined what the churn threshold is for the network, to maintain all data at a certain rate of churn. This will be a function of
the number of redundant objects in the storage system, as reliability can usually be increased with increased redundancy. What should be measured is
how well the system performs for a specific number of replicas used.

\subsubsection{Responsiveness}
To ensure system responsiveness, data must be stored or retrieved in real-time. With real-time, it is meant that data should be available within a
certain time frame that would ensure correct functionality of the MMOG requiring it. The variance in times when data become available should also be
small.

Responsiveness can be measured by the time it takes for an object to be available for reading, anywhere in the network, after having been written.
How long it takes to read or write data to the storage network can also be measured.

\subsubsection{Security}
The storing system should store data securely. It should not be possible for data to be altered in ways that are inconsistent with the game rules. It
should also be possible to identify nodes that alter the data in a malicious way. This also adds the requirement that nodes should be authenticated
in the storage system and that only authorised nodes should be able to alter data.

Security is the combination of a number of objectives. These are: Authentication, Authorisation, Data Integrity, Confidentiality, Availability,
Trust, Privacy and Identity Management \cite{distributed_systems_security}. When comparing different consistency techniques, it should first be
established which of these objectives does the scheme address. The number of objectives addressed, if addressed in industry standard ways, is already
a measure of the security of the system. Data integrity can be tested by ensuring the storage system can withstand the dropping, delay or, possibly,
the modification of data packets by malicious nodes in the network. Nodes can be programmed to randomly drop packets and the availability of the data
under these circumstances can be measured by the time it takes to rebuild a file under different rates of packet drops or delays.

\subsection{Super peer storage}
\label{super_peer_storage}

%Super peer storage - description
Super peer storage relies on the super peer storing all information that is in its domain. A domain is usually created by segmenting the world into
regions and super peers act as regional servers to all peers in their region. Each super peer handles all game logic and distributes updates to all
peers in its region. The super peer also handles state persistency for its region, hosting NPCs, objects and persistent player data.

\begin{figure*}[htbp]
 \centering
 \includegraphics[clip=true, viewport=2cm 5cm 27cm 16.5cm, width=\textwidth]{region_based_CS_CM}
 \caption{Region-based Client/Server consistency model}
 \label{fig_cs_region_cm}
\end{figure*}
%
The consistency model for this approach is depicted in Figure \ref{fig_cs_region_cm}. One can see that this approach is modelled on the update based
model, but segmented into separate regions. The role of the server is here fulfilled by a super peer, which is a peer that is selected in some
logical way, from the available set of peers and then promoted. Server selection in itself is a complex topic that has to deal with determining
whether a peer has sufficient resources available and also whether the peer is trustworthy.

Each super peer in this model houses the complete region state as shown. Super peers also house the real game logic. Clients in the region only house
copies of the regional objects and some client logic to update the local copies of objects housed. Like the \ac{CS} model, clients only send events
to super peers, where super peers apply the game logic and send state updates to clients.

\subsubsection{Fairness}
%Super peer storage - issues
The super peer storage model has many potential issues. Overloading of the super peer is one. A super peer could be relatively easily overloaded if a
region becomes too crowded, since a super peer is merely the computer of some player in the game and not a specialised server machine. The question
of fairness also arises. The idea of a P2P MMOG model is that all peers share resources. With this model, peers with extra resources are expected to
donate these resources for the good of all. Players might consider it unfair, when they are constantly expected to donate resources, some of which
they might have to pay for, while other players never contribute.

In a system with lower fairness, the individual user load is also higher for those users that do have to contribute resources. This means that in an
unfair system, the users that do have to contribute, have to contribute more than what they would have, were it a fair system.

\subsubsection{Reliability}
\label{super_peer_storage_reliability}

Another issue is reliability. In a P2P system, with a high rate of churn, players are expected to constantly leave and join the network. Because of
this reality, redundancy mechanisms have to be developed that would ensure state data are always available, even when a super peer leaves the
network. It is possible to solve these issues by having redundant super peers in each region that take over hosting responsibility when the main
super peer leaves.

It is important that the main and backup super peers always possess consistent states, even during a transition from main to backup. Other schemes to
support improved reliability deal with reputation mechanisms for super peers. Super peers that have more resources and stay in the network longer are
preferred during super peer selection, using reputation mechanisms \cite{fan_mediator_paper}.

\subsubsection{Security}
The third, and probably most important issue is that of security. If a single peer is allowed to house the player information of a large group of
players, it might become possible for such a peer to modify the data to suit his own ends. The issue is not only that modification of the data might
be possible, but also that it would not be possible for the cheating to be detected, because of no centralised logging.

A scheme that would improve the reliability of this systems has been proposed, where every event is also sent to the backup super peer of the region
\cite{past_storage_focus}. The main super peer responds with the update and the backup super peer responds with a hash of the update. A peer can then
check whether the hashes match to determine whether the data has been received correctly. A hash is not the state update itself, so will be much
smaller, but the events that have to be sent to all super peers will increase traffic in the network and bandwidth usage by peers.

\subsubsection{Responsiveness}
There are also advantages to super peer storage. All data are stored on the super peer, which means that storing data is a low latency operation. The
regional state can be stored and retrieved at very high speeds, making the system very responsive. Data retrieval from such a storage is also
relatively fast; as fast as data retrieval from a server. Peers can request data from a super peer and the data can be returned to the peer in one
hop after transmission of the request. Super peers may, however, become overloaded with requests and thereby increase the latency of the system.

\subsubsection{Existing architectures}

Knuttson et al. \cite{knutsson_p2p_first} employ regional coordinators to host all shared object states. The coordinator is chosen as the node whose
ID is closest to that of the region ID. The region ID is a SHA-1 hash of the region's textual name \cite{SHA}. This mapping makes it unlikely that
the coordinator will be a member of the region. The advantages of such a selection scheme is that the opportunities for cheating are reduced, because
the data are hosted on a peer that has no or little interest in the data, as described in Section \ref{distance_based_storage_security}.

Coordinator hand-offs also occur less than if the coordinator was an elected member of the region. If this is the case, a new coordinator has to be
chosen every time the current coordinator leaves the region. In this scheme, hand-offs only occur as a result of network churn, which is far lower
than the number of players moving from one region to another.

Reliability is achieved by maintaining backup coordinators as the \ac{DHT} neighbours of each region coordinator. One method by which redundant
region coordinators are maintained in \cite{knutsson_p2p_first}, is to create backup coordinators on peers with IDs closest to the current
coordinator. This means that if the main coordinator fails, all data will automatically be routed to the backup, because of the feature of \acp{DHT}.
This method is similar to how reliability is achieved in overlay storage as described in Section \ref{overlay_storage_reliability}.

\subsection{Overlay storage}
\label{overlay_storage}

Overlay storage entails using a distributed file storage system, which is based on a P2P overlay to host objects. PAST \cite{PAST_storage} uses
Pastry to implement a distributed storage system. Files that have to be stored are given IDs, by using some hash function, for example SHA-1
\cite{SHA}. The file, along with the ID are sent as a message over the overlay. The messages is then routed to the node whose ID is a closest match
of the file ID, where the file is stored. If any nodes wish to retrieve the file again, it only requires the file hash. A ``get'' message can be sent
to the overlay, where the overlay will route the message to where the file is situated and retrieve the file. A great advantage of this storage
technique is that the hash function is random, which ensures a good first order distribution of files over the complete key space.

%Also discuss Oceanstore and maybe Freenet
%Reference "A Survey of Peer-to-Peer Storage Techniques for Distributed File Systems" by Ragib Hasan, Zahid Anwar, William Yurcik, Larry Brumbaugh and Roy Campbell

%Overlay storage - reason
Overlay storage is a popular storage method, currently used by most P2P MMOG architectures. This is believed to be more as a consequence of the use
of Scribe than any inherit benefit to P2P MMOGs \cite{past_storage_focus}. This is also the motivation used in Chapter 4 of \cite{Fan_phd}, where the
Mediator architecture is described. Scribe is an implementation of \ac{alm} that uses the Pastry overlay as the structure to send multicast messages
over \cite{scribe}. The reason for using overlay storage in so many implementations seem to be merely the availability of PAST, after using Scribe.
The implementation of state persistency, however, does not have to be linked with the event dissemination scheme. A P2P overlay may be used for event
dissemination, and another method can be used to ensure state persistency.

\subsubsection{Reliability}
\label{overlay_storage_reliability}

Overlay storage can be made very reliable, using redundancy. One method used to achieve high reliability in PAST is to store $k$ replicas for any
file stored in PAST, in order to ensure the availability of the file. These replicas are stored at the neighbouring nodes of the node containing the
original file. Neighbours are the $k$ nodes whose IDs are closest to that of the root node. By the characteristics of \ac{DHT} distance-based
routing, if the node with the original data leaves the network, packets will automatically be routed to the neighbouring node, where the duplicate
will then be. This technique ensures high availability of data and the number of duplicates can be chosen according to the reliability of the
network.


\subsubsection{Responsiveness}
%Overlay storage - issues
The main issue with this mode of storage is summed up by the creators of PAST: ``Finally, PAST is intended as an archival storage and content
distribution utility and not as a general-purpose filesystem. It is assumed that users interact primarily with a conventional filesystem, which acts
as a local cache for files stored in PAST.'' \cite{storage_and_chaching_PAST}. This is not how file system interactions occur in MMOGs. For
responsive MMOGs, a distributed file system is required that allows for real-time file storage and retrieval.

The most significant issue with overlay storage is the delay incurred when storing and retrieving data. As data can be stored anywhere on the network
and the network is not fully connected, an average of $O(\log_{2^4}(N))$ hops are required to retrieve or store a data item using Pastry
\cite{storage_and_chaching_PAST}. Although this is a sufficient order complexity for a routing algorithm in a large network, it is not sufficient to
support a real-time application.

A mechanism that statistically reduces the delay of distributed file storage has been implemented in PAST \cite{storage_and_chaching_PAST}. Firstly,
the mechanism by which churn is handled, described in Section \ref{overlay_storage_reliability}, also improves responsiveness.  This is achieved,
because IDs created by the SHA-1 random hash function ensures that a nodes's neighbours are distributed randomly throughout the P2P overlay. This
random distribution ensures that file replicas are also uniformly distributed throughout the P2P overlay network.

In an effort to further increase responsiveness, PAST also employs caching techniques. If a node forwards many queries for a file, that node can
elect to cache the file to improve the responsiveness of the system. This caching can only occur if the node has space available. If a node has
cached a file and another file is explicitly inserted into the node, it can elect to remove the cached file in order to free up space. This means
that the success of the caching mechanism is directly related to the level of storage utilisation. Higher utilisation will prevent files from being
cached.

The article on caching in PAST shows a significant reduction in network delay when caching is used. Going from an average of more than two hops, down
to one hop for a network utilisation of 50\%. It is, however, not clear how this will change when 60,000 nodes are used, instead of the 2250 nodes
used in the presented experiment. The number of 60,000 nodes is based on the number of concurrent player experienced in Eve Online, a popular science
fiction MMORPG \cite{eve_pcu}. It is also important to note that these hops are Pastry overlay hops and not Internet Protocol (IP) level hops. One
Pastry hop can contain a multitude of IP level hops, depending on the organisation of the overlay network.

%Data migration in Oceanstore

\subsubsection{Security}
This model does have better security than the super peer storage model as data are distributed amongst all peers and redundancy and quorum techniques
can be implemented to ensure that files are retrieved with a high level of security.

To ensure a secure system, copies of files have to be saved at different locations. If a file is retrieved, all copies must be queried and received.
All received copies then have to be compared to ensure that the contents are correct. This introduces additional network overhead as well as
additional load on nodes to serve as file copies.

The network overhead can, however, be reduced by having file replica nodes only send hashes of the files, which may then be compared at the
requesting node. Hashes require much less bandwidth, while still allowing a requesting node to check update validity by hashing the received update
and comparing with the received hashes.

\subsubsection{Fairness}

Overlay storage is fair, as all nodes share file data and requests equally. The system might be made fairer by taking into account the heterogeneity
of peers. Peers do not all possess the same amount of resources, something which a truly fair system should take into account. The difficulty with
using such a scheme is that peers can be made to report incorrect resource information in order to reduce their resource donation requirement. This
is where incentive mechanisms have to be investigated as well as ways to ensure correct resource reporting.

\subsubsection{Existing architectures}

%Merabi, 2004 \cite{using_freenet_storage}
In 2004, Merabti and El Rhalibi mention the issue of ``Data Storage'' \cite{using_freenet_storage}. It is recognised that a distributed storage
scheme is required and that such a scheme ``\ldots requires careful designing\ldots''. The use of a data storage architecture based on the Freenet
project is proposed \cite{clarke_freenet}. Freenet is a distributed storage facility that uses a Darknet to ensure user anonymity when distributing
files. A system such as Freenet is designed for general file sharing, which means that no focus is placed on achieving the high levels of
responsiveness required for MMOGs. While the need for state persistency is briefly mentioned in the 2004 paper by Marabti and El Rhalibi, Douglas et
al. implement a workable solution for state persistency in 2005.

%Douglas, 2005 \cite{Douglas05enablingmassively}
Douglas et al. designed a P2P MMOG architecture in 2005 \cite{Douglas05enablingmassively} and implemented state persistency using a distributed
storage implementation, which they developed in 2003 \cite{Harwood03hashingspatial}. The storage system allows for the manipulation of spatial data,
while also implementing range queries. This enables the system to store and retrieve data that exist in a certain area of the game world. In the MMOG
architecture they developed, state persistency is implemented by the ``Spatial Data Service'' (SDS), which is a distributed storage architecture that
uses the Chord P2P overlay for routing \cite{chord}.

%Hampel, 2006 \cite{past_storage_focus}
Recently, PAST has become a popular way to implement state persistency. This is the approach proposed by both Hampel et al. in 2006
\cite{past_storage_focus} as well as Fan in 2009 \cite{Fan_phd}. In both of these publications, it is said that PAST is used to store the global game
state, but never is detailed what is stored and how regularly it is stored. Player information is supposed to be stored as game state, but from the
papers it is unclear how position updates are handled. It is not clear whether the last position of a player is stored at all or how regularly it is
stored. It is important to know how position updates are handled in the game, since position updates are the most common type of update
\cite{knutsson_p2p_first}.

The main difference between the implementation by Douglas et al. and the PAST implementations, is that the former supports range queries on spatial
data, which allows for a set of objects to be returned, queried by their virtual in-game position. With PAST, the exact ID of an object is required
before it may be retrieved. Using PAST is the simplest means by which game state persistency may be implemented, but PAST is not necessarily the
application best suited to game state persistency. There exists a need for more research into appropriate state persistency mechanisms for P2P MMOGs.

\subsection{Hybrid region-based storage}
\label{hybrid_storage}

%Overlay storage - description
\begin{figure*}[htbp]
 \centering
 \includegraphics[clip=true, viewport=2cm 5cm 27cm 19.5cm, width=\textwidth]{region_based_CS_CM_P2PO}
 \caption{Region-based Client/Server with overlay consistency model}
 \label{fig_cs_region_o_cm}
\end{figure*}
%
Figure \ref{fig_cs_region_o_cm} shows a type of Super Peer/Overlay hybrid storage implemented in \cite{zoned_federation}. The model depicted in
Figure \ref{fig_cs_region_o_cm} uses an overlay storage, managed by regional super peers. The world is divided into regions, with each region
controlled by a super peer. The complete region state is cached at every super peer, the same as with super peer storage. There also exists a backup
overlay storage architecture, to which data may be backed up for long term, redundant and secure storage. The hybrid region-based overlay storage
contains many improvements over pure overlay storage.

\subsubsection{Reliability}
\label{hybrid_storage_reliability}

Because of the use of overlay storage for backup, the hybrid region-based storage is almost as reliable as a pure overlay storage. It is classified
as almost as reliable, because there exists a time lag between when data changes and when it is updated in the overlay. If a super peer fails during
this time and the data was not backed-up to the overlay, that data could be lost. Backup super peers can, however, be implemented as described in
Section \ref{super_peer_storage_reliability} to further improve the reliability of the hybrid storage model.

\subsubsection{Responsiveness}

Because all regional files are cached at super peers, the system is as responsive as super peer storage.

\subsubsection{Security}

Security in hybrid storage is still an issue, because of the inherent problems of the super peer storage model. Although it is more difficult for
nodes to access and manipulate data stored in the overlay, a malicious node promoted to super peer status may manipulate the region data it controls.

\subsubsection{Fairness}

The issue of unfairness is also still present in hybrid storage. The system is fairer in that all nodes share the load of the overlay storage, but
there still exists the unfairness of the super peer storage. As all data exists in both the overlay storage as well as the super peer storage, the
system is as unfair as super peer storage, because the same amount of data as in super peer storage is not being distributed evenly amongst all
nodes.

\subsubsection{Existing architectures}

\begin{figure}[htbp]
 \centering
 \includegraphics[clip=true, viewport=2cm 0cm 19cm 30cm, angle=-90, width=\columnwidth]{zoned_federation_model}
 \caption{Zoned Federation Model \cite{zoned_federation}}
 \label{fig_zoned_federation_model}
\end{figure}
%
The first hybrid state persistency model for P2P MMOGs was proposed by Iimura et al. in 2004 \cite{zoned_federation} and called the ``Zoned
Federation Model'', shown in Figure \ref{fig_zoned_federation_model}. The regional super peers are called ``Zone Owners'', which handle all events by
clients in their zone or region. In the Zoned Federation model, a Zone Owner acts as the primary storage medium for all object states in the zone or
region. As shown in Figure \ref{fig_cs_region_o_cm}, this is analogous to an update based model, divided into zones. The difference here is that the
game state of all zone owners are regularly backed-up to overlay storage. The zoned federation model can thus be seen as a super peer/overlay storage
hybrid. The super peers storage provides for low latency data storage and the overlay storage provides security and reliability.

An extended abstract, published by GauthierDickey et al. in 2004 \cite{hybrid_storage1}, proposed to distinguish between permanent and ephemeral
data. Permanent data are described as data that should exist at all times and ephemeral data are described as data that need only exist for as long
as its owner is in the game. An item, being dropped by a dispatched NPC, can be considered as ephemeral. When the peer on which the data is hosted
leaves the area, that item can disappear. An example of permanent data are a player's inventory contents, which can further be classified as
participatory data or a player's house, which can be classified as existential data. Participatory data are data that need only be available when a
specific player is in the game and existential data are data that should be available, even when a certain player is not present in the game.

Categorising data by how long and under which circumstances the data should exist, may assist in the design of the storage model. Since ephemeral
data does not have to exist after the player has left the game, it may be stored in primary memory. Participatory data might also be stored on the
player's computer, but security issues will have to be kept in mind. Existential data will have to be stored somewhere other than on the player's
computer, since other player will require the data, even in the absence of the player that might have left the game. GauthierDickey et al. did not
explore how their data classification scheme might be translated into a state persistency model.

\subsection{Distance-based storage}
\label{distance_based_storage}

%Distance-based - overview
Distance based approaches, such as the Voronoi storage approaches \cite{Buyukkaya_voronoi_state_management}, \cite{Hu_voronoi_IM} and also some more
general approaches \cite{colyseus_distance_based}, \cite{solipsis}, store object data on the peer closest to the object in the virtual world. Some
distance metric is used to determine on which node an object should be stored.

\begin{figure}[htbp]
 \centering
 \includegraphics[width=\columnwidth]{voronoi_diagram}
 \caption{Voronoi Diagram \cite{Buyukkaya_voronoi_state_management}}
 \label{fig_voronoi_diagram}
\end{figure}
%
Given a set of points, the Voronoi diagram of the set of points is the partition of the plane, which associates a region around every point in such a
way that all other points contained in the region are closer to the centre point than any other point in the set. Figure \ref{fig_voronoi_diagram}
shows a Voronoi diagram, where the lines define the region boundaries, the dots define the players, which make up the set of points for which the
diagram was calculated, the plus signs represent mutable objects and the circle represents the \ac{AoI} of a central point in the set.

For the Voronoi approaches, described in more detail in Section \ref{distance_based_existing_archs}, a node controls and hosts all objects within its
Voronoi region. The reasoning is that there is a high probability that the player closest to the object is also the player using the object. Examples
of this are where a player is trading or fighting with an NPC.

\subsubsection{Responsiveness}

%Distance-based - issues
The only problem with this reasoning is that usually multiple nodes are interacting with a single object. The examples of the NPC monster and trader
are again relevant. Usually many players interact with a trader NPC and usually players attack monster NPCs in groups.

Multiple player interactions are, however, not as big an issue as others have made it out to be \cite{Fan_deisgn_issues_p2p}. In the best case, the
object being used by a player is also hosted on that player's node. If another player requires use of a remotely hosted object, that player may still
interact with the object, where the host node is now acting as a server to that player. This means that every player hosting an object becomes a
server for that object. In the case where a player interacts with an object hosted locally, there is no object latency. In the case where a player
accesses a remotely hosted object, there is only one hop latency, the same as with a \ac{CS} or super peer application. The advantage, however, is
that the total server load for all objects is distributed amongst all peers, which means that each peer should have to handle much less queries than
with the super peer storage approach. This might protect peers from becoming overloaded and improve latency.

Issues with this approach stem from the fact the players are constantly moving. When players move, the objects in their regions change. Objects,
therefore, have to be constantly handed over from one peer to another, which might cause significant network traffic. An object in transit might also
delay interaction with that object. Because object transfer introduces overhead into the system, how regularly an object has to be transferred and
whether the number of transferrals produce sufficiently low overhead to implement a real-time game, still have to be investigated.

Voronoi-based storage schemes also become unresponsive when communications are no longer between neighbours, but between two arbitrary nodes in the
Voronoi overlay. When such communications occur, the average required time to route a message is $\OO{N^{1/2}}$ for a two-dimensional configuration.
Advancements have been made that suggest augmenting the Voronoi overlay with additional links to far off nodes to create a small world network. This
reduces the average routing time to $\OO{\log{N}}$, the same as for overlay storage \cite{Steiner_voronoi_shortcuts}.

\subsubsection{Reliability}

Reliability is still an open issue, because of network churn. When nodes leave the network, the objects that they controlled should still be
accessible. No papers have yet dealt with the issue of reliability in distance-based storage network. The same solution that is used for overlay
storage, namely the presence of redundant peers, might also be implemented for distance storage. Another structured overlay might even be used to
implement this redundancy in exactly the same way it is done with overlay storage.

\subsubsection{Security}
\label{distance_based_storage_security}

The main issue with the distance based scheme is security. Nodes that have the most interest in an object also have the most interest to manipulate
that object in ways inconsistent with the game rules. When objects are hosted on nodes that have the most interest in them, there will be a strong
drive to try and manipulate these objects. Because these modification are all local, it is also not possible to log the alterations and detect
cheating. Means by which local objects can be secured have to be found or distance based algorithms with quorum need to be investigated.

\subsubsection{Fairness}

Distance-based storage is relatively fair as all objects are distributed amongst all nodes. Where the system becomes somewhat unfair is when a node
is nearest to a large number of objects. For Voronoi regioning approaches, this is when a peer's Voronoi region contains many more objects than the
average number of objects hosted by other peers. This might not be a major issue, depending on how long the objects have to be hosted on the
overloaded peer. This will depend on the movement of the overloaded peer as well as that of neighbouring peers. The use of aggregators as a proposed
solution to this problem is discussed in Section \ref{distance_based_existing_archs}.

\subsubsection{Existing architectures}
\label{distance_based_existing_archs}

%Colyseus, 2006
Bharambe et al. created the Colyseus architecture in 2006 \cite{colyseus_distance_based}. The architecture is designed to support First Person
Shooter (FPS) games and implemented to function with Quake II. Mutable game objects are stored on the peer that is nearest to the object in the game
world. An ``object placer'' component is mentioned, but the details of the placement algorithm are left for future work. The architecture also does
not implement non-volatile state persistency, since this is not required for normal FPS games, where object states need only exist to the end of a
round and where players generally do not leave before the end of the round. This means that object states are only stored in primary memory, until
the end of a game round.

%Solipsis, 2008
The Solipsis architecture was created by Frey et al. in 2008 \cite{solipsis}. The architecture uses Voronoi diagrams to create virtual regions.
Stationary objects are maintained by site nodes until a player picks up an object. When an object is picked up, control of that object is transferred
to the player that picked up the object. The Solipsis architecture focusses on distributed physics computation and when a player gains control of an
object, that player is responsible for the object's physics computations. That player should also save all object state until a new player takes the
object, at which time control is transferred to her. Control can also be transferred back to a site node if an object remains stationary for some
time.

That differentiates the Solipsis distance-based storage from the other architectures presented in this section, is that object states are only
handled by peers as long as those peers directly use an object. At other times, those objects are handled by site nodes. This differs from other
distance-based storage techniques, where all objects that are nearest to a player in the virtual world are controlled by that player.

%Buyukkaya and Abdallah, 2008 and Hu et al., 2008
In 2008, papers were published by Buyukkaya and Abdallah \cite{Buyukkaya_voronoi_state_management}, and Hu et al. \cite{Hu_voronoi_IM}, proposing to
use Voronoi diagrams \cite{voronoi_diagrams_survey} to implement distance-based storage. Voronoi state management schemes host the mutable objects on
the peer in which region the object exists. As peers move around in the virtual world, the Voronoi diagram has to be constantly recalculated and
objects have to be moved to new owner peers as the regions in which they fall change. The significant advantage of the Voronoi approach is that peers
only require connections with their neighbours, and peers within their AoI.

A thesis by Chang also describes the Voronoi approach in more detail and how to achieve game state consistency amongst all nodes in a Voronoi network
\cite{Chang_Voronoi_state_management_masters}. What distinguishes this work from the others is the implementation of a load balancing mechanism. When
peers get overloaded, another, more powerful peer is chosen as an Aggregator. The Aggregator assumes responsibility for a larger area that
encompasses multiple peers. This scheme will reduce the load on peers with minimal resources, but it is uncertain how this would reduce load when
peers with an average amount of resources in an area become overloaded.

These works form part of the VAST project, which is being created to be a fully functional P2P overlay architecture, using Voronoi diagrams as its
basis \cite{VAST}.

The reason why state persistency in Voronoi-based P2P MMOGs architectures are mostly distance-based approaches, is because the Voronoi diagram
immediately identifies which objects are closest to a particular peer, and therefore, which objects that peer has to host. Architectures not making
use of Voronoi diagrams still require some other mechanism to identify which objects which peers should host.

\section{Conclusion}


After providing an overview of the classic C/S and C/MS state persistency techniques, this survey classified P2P MMOG state persistency techniques
into super peer based, overlay based, distance based and hybrid storage. The advantages and disadvantages of each method were discussed after
identifying key challenges that state persistency techniques have to solve. These challenges are: Reliability, Security, Fairness and Responsiveness.

What can be concluded after all the state persistency methods were reviewed is that there exists no single state persistency architecture, currently
in use, that is suited to P2P MMOGs. None of the storage techniques reviewed meet the requirements of a real-time distributed application, such as an
MMOG. What is required is a state persistency architecture, specifically geared towards data persistency in P2P MMOGs, that meet all the challenges
of the application.

This survey was written, because of an identified need for a concise summary of the field of P2P MMOG game state persistency. Many techniques used in
the past were used because of the ease with which they could be integrated into a P2P MMOG. The purpose of this survey is to identify those
techniques and to stimulate further research, using empirical methods to compare the different storage techniques used.

%\newpage
%\IEEEtriggeratref{43} %Balance the bibliography
\bibliographystyle{IEEEtran}
\bibliography{../BibTeX/P2P_MMOG}

% that's all folks
\end{document}
